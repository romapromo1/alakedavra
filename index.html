<!doctype html>
<html lang="ru">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>3D Игра — Падение Объектов</title>
    <style>
      html, body {
        margin: 0;
        padding: 0;
        background: #ffffff;
        color: #fff;
        height: 100%;
        overflow: hidden;
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      }

      /* Контейнер с заданным соотношением сторон 9:16 (2160x3840) */
      .game {
        position: relative;
        height: 100vh;
        width: auto;
        aspect-ratio: 9 / 16;
        margin: 0 auto;
        touch-action: none;
        user-select: none;
      }

      /* Канвас будет растягиваться под контейнер, но рендерим внутрь 2160x3840 */
      canvas {
        width: 100%;
        height: 100%;
        display: block;
      }

      .ui {
        position: absolute;
        inset: 0;
        pointer-events: none;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .gameover {
        font-weight: 800;
        letter-spacing: 0.06em;
        color: #ff4d4d;
        text-shadow: 0 2px 6px rgba(0,0,0,0.6), 0 0 24px rgba(255,77,77,0.6);
        opacity: 0;
        transform: scale(0.95);
        transition: opacity 300ms ease, transform 300ms ease;
        text-align: center;
      }

      .gameover.visible {
        opacity: 1;
        transform: scale(1);
      }

      /* Размер текста под целевое разрешение */
      .gameover h1 {
        margin: 0;
        font-size: clamp(32px, 8vmin, 160px);
      }

      .hint {
        position: absolute;
        left: 50%;
        bottom: 1.5rem;
        transform: translateX(-50%);
        color: #cbd5e1;
        font-size: clamp(12px, 2.4vmin, 28px);
        opacity: 0.9;
      }

      /* Всплывающий счет монет справа */
      .coin-flash {
        position: absolute;
        right: 1.5rem;
        top: 50%;
        transform: translateY(-50%);
        font-weight: 800;
        color: #f59e0b;
        text-shadow: 0 2px 6px rgba(0,0,0,0.2), 0 0 18px rgba(245,158,11,0.35);
        opacity: 0;
        transition: opacity 240ms ease, transform 240ms ease;
        font-size: clamp(18px, 5vmin, 96px);
        pointer-events: none;
      }
      .coin-flash.visible {
        opacity: 1;
        transform: translateY(-50%) scale(1.02);
      }

      /* Индикатор отслеживания руки */
      .hand-indicator {
        position: absolute;
        left: 1rem;
        top: 1rem;
        background: rgba(0,0,0,0.45);
        color: #fff;
        border-radius: 9999px;
        padding: 0.35rem 0.7rem;
        display: inline-flex;
        align-items: center;
        gap: 0.5rem;
        font-size: clamp(12px, 2.2vmin, 22px);
        line-height: 1;
        pointer-events: none;
      }
      .hand-indicator .dot {
        width: 0.75em;
        height: 0.75em;
        border-radius: 50%;
        background: #ef4444; /* off */
        box-shadow: 0 0 10px rgba(239,68,68,0.4);
      }
      .hand-indicator.on .dot {
        background: #22c55e; /* on */
        box-shadow: 0 0 10px rgba(34,197,94,0.6);
      }

      /* Превью камеры в правом нижнем углу */
      .cam-preview {
        position: absolute;
        right: 1rem;
        bottom: 1rem;
        width: min(28%, 360px);
        height: auto;
        border-radius: 10px;
        box-shadow: 0 8px 24px rgba(0,0,0,0.25);
        opacity: 0.6;
        pointer-events: none;
        transform: scaleX(-1) translateZ(0); /* зеркалим по X */
      }
    </style>
  </head>
  <body>
    <div class="game" id="game">
      <div class="ui">
        <div class="gameover" id="gameover">
          <h1>ГАМОВЕР</h1>
        </div>
      </div>
      <div class="hint">Двигайте мышью, избегайте объектов</div>
      <div class="coin-flash" id="coinFlash">+0</div>
      <div class="hand-indicator" id="handIndicator"><span class="dot"></span><span class="label">Рука: нет</span></div>
    </div>

    <!-- Three.js из CDN -->
    <script src="https://unpkg.com/three@0.159.0/build/three.min.js"></script>
    <!-- MediaPipe Hands + Camera utils -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script>
      (() => {
        // Целевое внутреннее разрешение рендера
        const RENDER_WIDTH = 2160;
        const RENDER_HEIGHT = 3840;
        const ASPECT = RENDER_WIDTH / RENDER_HEIGHT; // 9:16

        // Игровые размеры мира под ортографическую камеру (в условных единицах)
        const halfW = 1080; // соответствует 2160 ширины
        const halfH = 1920; // соответствует 3840 высоты

        // Параметры игры
        const OBJECT_SIZE = 160; // «размер» объектов (диаметр ориентировочно)
        const MIN_DISTANCE = 1.5 * OBJECT_SIZE; // не ближе этого
        const BASE_FALL_SPEED = 320; // базовая скорость падения
        const MAX_VX = 200;     // базовое случайное смещение по X (ед/сек)
        const FUNNEL_STRENGTH = 1.5; // стремление к центру ближе к низу
        const SPAWN_INTERVAL_BASE = 1.0;  // сек
        const ROT_SPEED = 0.6; // базовая скорость вращения
        const PLAYER_MOVE_Y = 660; // «немного» вверх/вниз по оси Y
        const PLAYER_SIZE = OBJECT_SIZE; // игрок — куб того же размера

        // Жесты руки (MediaPipe)
        const ENABLE_HANDS = true;        // можно отключить при желании
        const HAND_MIRROR_X = true;       // отзеркалить по X для интуитивного управления
        const HAND_INVERT_X = true;       // инвертировать управление по X
        const HAND_SMOOTH = 0.25;         // сглаживание движения руки (0..1)

        // Спавн золотой монетки
        const COIN_INTERVAL = 5.0; // каждые 5 секунд

        // Магнитное отталкивание между падающими объектами
        const REPULSION_RADIUS = OBJECT_SIZE * 8.2; // радиус действия отталкивания
        const REPULSION_STRENGTH = 9800;            // сила (настройка)
        const VX_CLAMP = 420;                       // ограничение по X-скорости от отталкивания
        const VY_CLAMP = 220;                       // ограничение по Y-скорости
        const DAMPING = 0.992;                      // легкое затухание накопленных скоростей
        const BOUNCE_X = 0.85;                      // коэф. упругости отскока от боковых стен

        const TOP_Y = halfH - OBJECT_SIZE * 1.2;
        const BOTTOM_Y = -halfH + OBJECT_SIZE * 1.2;
        const VANISH_RADIUS_X = OBJECT_SIZE * 0.9;

        const container = document.getElementById('game');
        const gameoverEl = document.getElementById('gameover');
        const coinFlashEl = document.getElementById('coinFlash');
        const handIndicatorEl = document.getElementById('handIndicator');

        // Видеопоток для MediaPipe (скрыт)
        const videoEl = document.createElement('video');
        videoEl.playsInline = true;
        videoEl.muted = true;
        videoEl.autoplay = true;
        videoEl.id = 'camPreview';
        videoEl.className = 'cam-preview';
        container.appendChild(videoEl);

        // Сцена
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xffffff);

        // Камера — перспективная. Подбираем дистанцию, чтобы на плоскости z=0
        // видимая область по высоте совпадала с 2*halfH
        const FOV = 50; // вертикальный угол обзора в градусах
        const camera = new THREE.PerspectiveCamera(FOV, ASPECT, 0.1, 8000);
        const fovRad = THREE.MathUtils.degToRad(FOV * 0.5);
        const dist = halfH / Math.tan(fovRad);
        camera.position.set(0, 0, dist);
        camera.lookAt(0, 0, 0);

        // Рендерер
        const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: 'high-performance' });
        renderer.setPixelRatio(1);
        renderer.setSize(RENDER_WIDTH, RENDER_HEIGHT, false);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        container.appendChild(renderer.domElement);

        // Свет
        const hemi = new THREE.HemisphereLight(0xffffff, 0xffffff, 0.8);
        scene.add(hemi);
        const dir = new THREE.DirectionalLight(0xffffff, 1.8);
        // Размещаем источник на расстоянии камеры, чуть правее и чуть выше центра
        dir.position.set(halfW * 0.35, halfH * 0.12, dist);
        dir.target.position.set(0, 0, 0);
        dir.castShadow = true;
        dir.shadow.mapSize.set(2048, 2048);
        dir.shadow.radius = 50.5; // более размытая тень (PCFSoft)
        // Расширяем зону покрытия теней на весь экран
        dir.shadow.camera.left = -halfW * 2.4;
        dir.shadow.camera.right = halfW * 2.4;
        dir.shadow.camera.top = halfH * 2.4;
        dir.shadow.camera.bottom = -halfH * 2.4;
        dir.shadow.camera.near = 1;
        dir.shadow.camera.far = 8000;
        dir.shadow.bias = -0.0006;
        // Применяем изменения параметров ортокамеры теней
        dir.shadow.camera.updateProjectionMatrix();
        scene.add(dir);
        scene.add(dir.target);

        // Источник света снизу — мягкий направленный вверх
        const under = new THREE.DirectionalLight(0xffffff, 0.6);
        under.position.set(0, -1200, 400);
        under.target.position.set(0, 0, 0);
        scene.add(under);
        scene.add(under.target);

        // Задняя «стена» принимает только тени, фон остаётся идеально белым
        const backGeom = new THREE.PlaneGeometry(halfW * 8.4, halfH * 4.2);
        const backMat = new THREE.ShadowMaterial({ color: 0x000000, opacity: 0.22 });
        const backWall = new THREE.Mesh(backGeom, backMat);
        backWall.position.set(0, 0, -600);
        backWall.receiveShadow = true;
        scene.add(backWall);
        

        // Игрок — управляемый куб
        const playerMat = new THREE.MeshStandardMaterial({ color: 0x38bdf8, roughness: 0.4, metalness: 0.1 });
        const playerGeo = new THREE.BoxGeometry(PLAYER_SIZE, PLAYER_SIZE, PLAYER_SIZE);
        const player = new THREE.Mesh(playerGeo, playerMat);
        player.position.set(0, 0, 0);
        player.castShadow = true;
        scene.add(player);
        const playerRadius = PLAYER_SIZE * 0.6;

        // Убрано: фоновые ориентиры (сетка)

        // Хранилища
        /** @type {Array<{mesh:THREE.Object3D, vx:number, vy:number, rot:THREE.Vector3, radius:number, isCoin?:boolean}>} */
        const objects = [];
        /** @type {Array<{mesh:THREE.Mesh, vel:THREE.Vector3, life:number}>} */
        const particles = [];

        // Состояние
        let running = true;
        let spawnAccumulator = 0;
        let spawnInterval = SPAWN_INTERVAL_BASE;
        let spawnIntervalTimer = 0; // каждые 2 сек сокращаем интервал *1/1.1
        let coinAccumulator = 0;
        let lastTime = performance.now() / 1000;
        let coinCount = 0;
        let coinFlashTimer = null;
        // Динамическая скорость падения
        let fallSpeed = BASE_FALL_SPEED;
        let fallSpeedTimer = 0; // каждые 10 сек ускоряемся в 1.3x

        // Утилиты
        const randColor = () => new THREE.Color().setHSL(Math.random(), 0.7 + Math.random() * 0.3, 0.5 + Math.random() * 0.2);
        const randRange = (a, b) => a + Math.random() * (b - a);

        function makeRandomMesh() {
          const material = new THREE.MeshStandardMaterial({ color: randColor(), roughness: 0.5, metalness: 0.15 });

          const choice = Math.floor(Math.random() * 6);
          let geom;
          const s = OBJECT_SIZE;
          switch (choice) {
            case 0: geom = new THREE.SphereGeometry(s * 0.5, 24, 16); break;                // шар
            case 1: geom = new THREE.BoxGeometry(s, s, s); break;                            // куб
            case 2: geom = new THREE.TorusGeometry(s * 0.42, s * 0.20, 12, 24); break;       // тор
            case 3: geom = new THREE.IcosahedronGeometry(s * 0.58); break;                   // икосфера
            case 4: geom = new THREE.ConeGeometry(s * 0.6, s * 1.1, 4); break;               // пирамида (основание квадрат) 
            case 5: geom = new THREE.ConeGeometry(s * 0.6, s * 1.1, 16); break;              // конус
          }
          const mesh = new THREE.Mesh(geom, material);
          mesh.castShadow = true;
          mesh.receiveShadow = false;
          const radius = s * 0.6;
          return { mesh, radius };
        }

        function makeCoin() {
          const s = OBJECT_SIZE;
          const SCALE = 1.5; // увеличиваем монетку в 1.5 раза
          const thickness = Math.max(6, s * 0.18 * SCALE);
          const geom = new THREE.CylinderGeometry(s * 0.48 * SCALE, s * 0.48 * SCALE, thickness, 32);
          const mat = new THREE.MeshStandardMaterial({ color: 0xf5c542, metalness: 0.8, roughness: 0.2, emissive: 0xffcc33, emissiveIntensity: 1.2 });
          const coin = new THREE.Mesh(geom, mat);
          coin.rotation.z = Math.PI * 0.5; // сделать «монеткой»
          coin.castShadow = true;

          // Убираем любые «фоны»: без ауры и дополнительного свечения — остаётся только сама монета

          const radius = s * 0.6 * SCALE;
          return { mesh: coin, radius };
        }

        function canPlaceAt(x, y, radius) {
          for (const o of objects) {
            const dx = o.mesh.position.x - x;
            const dy = o.mesh.position.y - y;
            const d2 = dx * dx + dy * dy;
            const min = MIN_DISTANCE;
            if (d2 < min * min) return false;
          }
          return true;
        }

        function spawnWave() {
          const count = 1 + Math.floor(Math.random() * 3); // 1..3
          const spawned = [];
          let attempts = 0;
          const spreadX = OBJECT_SIZE * 3.2;
          while (spawned.length < count && attempts < 60) {
            attempts++;
            const ox = randRange(-spreadX, spreadX);
            const oy = TOP_Y + randRange(-OBJECT_SIZE * 0.4, OBJECT_SIZE * 0.4);
            // проверка на дистанцию между уже созданными в этом спавне
            let ok = true;
            for (const s of spawned) {
              const dx = s.x - ox;
              const dy = s.y - oy;
              if (dx * dx + dy * dy < MIN_DISTANCE * MIN_DISTANCE) { ok = false; break; }
            }
            if (!ok) continue;
            // проверка с ранее существующими объектами
            if (!canPlaceAt(ox, oy, OBJECT_SIZE * 0.6)) continue;

            spawned.push({ x: ox, y: oy });
          }

          for (const pos of spawned) {
            const { mesh, radius } = makeRandomMesh();
            mesh.position.set(pos.x, pos.y, 0);
            const vx = randRange(-MAX_VX, MAX_VX);
            const vy = 0;
            const rot = new THREE.Vector3(randRange(-ROT_SPEED, ROT_SPEED), randRange(-ROT_SPEED, ROT_SPEED), randRange(-ROT_SPEED, ROT_SPEED));
            scene.add(mesh);
            objects.push({ mesh, vx, vy, rot, radius });
          }
        }

        function spawnCoin() {
          // Пытаемся поставить монету сверху, недалеко от центра по X, без пересечений
          let attempts = 0;
          const spreadX = OBJECT_SIZE * 2.4;
          while (attempts++ < 40) {
            const x = randRange(-spreadX, spreadX);
            const y = TOP_Y + randRange(-OBJECT_SIZE * 0.4, OBJECT_SIZE * 0.4);
            if (!canPlaceAt(x, y, OBJECT_SIZE * 0.6)) continue;
            const { mesh, radius } = makeCoin();
            mesh.position.set(x, y, 0);
            const vx = randRange(-MAX_VX, MAX_VX);
            const vy = 0;
            const rot = new THREE.Vector3(randRange(-ROT_SPEED, ROT_SPEED), randRange(-ROT_SPEED, ROT_SPEED), randRange(-ROT_SPEED, ROT_SPEED));
            scene.add(mesh);
            objects.push({ mesh, vx, vy, rot, radius, isCoin: true });
            break;
          }
        }

        function flashCoinCount() {
          coinFlashEl.textContent = `+${coinCount}`;
          coinFlashEl.classList.add('visible');
          if (coinFlashTimer) clearTimeout(coinFlashTimer);
          coinFlashTimer = setTimeout(() => {
            coinFlashEl.classList.remove('visible');
          }, 900);
        }

        function collectCoin(index) {
          const o = objects[index];
          if (!o) return;
          // небольшая золотая «искрящаяся» вспышка
          const pos = o.mesh.position.clone();
          for (let i = 0; i < 40; i++) {
            const size = randRange(4, 10);
            const geom = new THREE.BoxGeometry(size, size, size);
            const mat = new THREE.MeshStandardMaterial({ color: 0xffd166, roughness: 0.35, metalness: 0.3, emissive: 0xffc34d, emissiveIntensity: 0.8 });
            const p = new THREE.Mesh(geom, mat);
            p.position.copy(pos);
            scene.add(p);
            const dir = new THREE.Vector3(randRange(-1, 1), randRange(-1, 1), randRange(-1, 1)).normalize();
            const speed = randRange(180, 520);
            particles.push({ mesh: p, vel: dir.multiplyScalar(speed), life: 0.8 });
          }
          scene.remove(o.mesh);
          objects.splice(index, 1);
          coinCount += 1;
          flashCoinCount();
        }

        function explodeAt(position) {
          const COUNT = 80;
          for (let i = 0; i < COUNT; i++) {
            const size = randRange(6, 16);
            const geom = new THREE.BoxGeometry(size, size, size);
            const mat = new THREE.MeshStandardMaterial({ color: 0xff5555, roughness: 0.4, metalness: 0.05 });
            const p = new THREE.Mesh(geom, mat);
            p.position.copy(position);
            scene.add(p);
            const dir = new THREE.Vector3(randRange(-1, 1), randRange(-1, 1), randRange(-1, 1)).normalize();
            const speed = randRange(200, 600);
            particles.push({ mesh: p, vel: dir.multiplyScalar(speed), life: 1.2 });
          }
        }

        function resetGame() {
          // удалить объекты
          for (const o of objects) scene.remove(o.mesh);
          objects.length = 0;
          for (const p of particles) scene.remove(p.mesh);
          particles.length = 0;
          // восстановить игрока
          player.visible = true;
          player.position.set(0, 0, 0);
          gameoverEl.classList.remove('visible');
          spawnAccumulator = 0;
          spawnInterval = SPAWN_INTERVAL_BASE;
          spawnIntervalTimer = 0;
          fallSpeed = BASE_FALL_SPEED;
          fallSpeedTimer = 0;
          running = true;
        }

        function gameOver() {
          if (!running) return;
          running = false;
          // взрыв и скрыть игрока
          explodeAt(player.position);
          player.visible = false;
          // показать ГАМОВЕР
          gameoverEl.classList.add('visible');
          // рестарт через 3 сек
          setTimeout(resetGame, 3000);
        }

        function setPlayerWorld(worldX, worldY) {
          const margin = OBJECT_SIZE * 0.8;
          const clampedX = Math.max(-halfW - 1 + margin, Math.min(halfW + 1 - margin, worldX));
          const clampedY = Math.max(-PLAYER_MOVE_Y, Math.min(PLAYER_MOVE_Y, worldY));
          player.position.x = clampedX;
          player.position.y = clampedY;
        }

        // Управление мышью: пересечение луча с плоскостью z=0
        function handlePointer(clientX, clientY) {
          const rect = container.getBoundingClientRect();
          const ndcX = ((clientX - rect.left) / rect.width) * 2 - 1; // -1..1
          const ndcY = -(((clientY - rect.top) / rect.height) * 2 - 1);
          const origin = new THREE.Vector3();
          const dir = new THREE.Vector3(ndcX, ndcY, 0.5).unproject(camera).sub(camera.position).normalize();
          origin.copy(camera.position);
          const t = -origin.z / dir.z; // плоскость z=0
          const hitX = origin.x + dir.x * t;
          const hitY = origin.y + dir.y * t;
          setPlayerWorld(hitX, hitY);
        }

        container.addEventListener('mousemove', (e) => handlePointer(e.clientX, e.clientY));
        container.addEventListener('touchmove', (e) => {
          if (e.touches && e.touches.length) {
            const t = e.touches[0];
            handlePointer(t.clientX, t.clientY);
          }
        }, { passive: true });

        // Анимация
        function centerFactor(pos) {
          const rx = Math.abs(pos.x) / halfW;
          const ry = Math.abs(pos.y) / halfH;
          const r = Math.hypot(rx, ry);
          const f = 1 - Math.min(1, r);
          return f * f; // квадратично усиливаем эффект ближе к центру
        }

        // Захват руки через MediaPipe
        let handSeenAt = 0;
        let handTarget = { x: 0, y: 0 };
        let handActive = false;

        async function setupHands() {
          if (!ENABLE_HANDS || typeof Hands === 'undefined' || typeof Camera === 'undefined') return;
          try {
            const hands = new Hands({
              locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
            });
            hands.setOptions({
              maxNumHands: 1,
              modelComplexity: 1,
              selfieMode: true,
              minDetectionConfidence: 0.6,
              minTrackingConfidence: 0.6
            });
            hands.onResults((results) => {
              if (results.multiHandLandmarks && results.multiHandLandmarks.length) {
                const lm = results.multiHandLandmarks[0][8]; // кончик указательного пальца
                let x = lm.x; // 0..1 слева направо
                let y = lm.y; // 0..1 сверху вниз
                if (HAND_MIRROR_X) x = 1 - x;
                const worldX = ((x - 0.5) * 2 * halfW) * (HAND_INVERT_X ? -1 : 1);
                const worldY = (0.5 - y) * 2 * halfH;
                handTarget.x = worldX;
                handTarget.y = worldY;
                handSeenAt = performance.now();
              }
            });

            const cam = new Camera(videoEl, {
              onFrame: async () => {
                await hands.send({ image: videoEl });
              },
              width: 640,
              height: 480
            });
            await cam.start();
          } catch (e) {
            console.warn('Hands init failed', e);
          }
        }

        function animate() {
          const now = performance.now() / 1000;
          const dt = Math.min(0.05, now - lastTime);
          lastTime = now;

          if (running) {
            spawnAccumulator += dt;
            // Уменьшаем интервал спавна: каждые 2 сек делим на 1.1
            spawnIntervalTimer += dt;
            if (spawnIntervalTimer >= 2) {
              spawnIntervalTimer -= 2;
              spawnInterval /= 1.1;
              // Минимальный предел, чтобы не ушло в бесконечный спавн
              if (spawnInterval < 0.15) spawnInterval = 0.15;
            }
            // Ускорение падения: каждые 10 секунд ×1.3
            fallSpeedTimer += dt;
            if (fallSpeedTimer >= 2) {
              fallSpeedTimer -= 2;
              fallSpeed *= 1.2;
            }
            coinAccumulator += dt;
            if (spawnAccumulator >= spawnInterval) {
              spawnAccumulator -= spawnInterval;
              spawnWave();
            }
            if (coinAccumulator >= COIN_INTERVAL) {
              coinAccumulator -= COIN_INTERVAL;
              spawnCoin();
            }

            // Магнитное отталкивание (попарно)
            if (objects.length > 1) {
              for (let i = 0; i < objects.length - 1; i++) {
                const A = objects[i];
                const aPos = A.mesh.position;
                for (let j = i + 1; j < objects.length; j++) {
                  const B = objects[j];
                  const bPos = B.mesh.position;
                  const dx = aPos.x - bPos.x;
                  const dy = aPos.y - bPos.y;
                  const d2 = dx*dx + dy*dy;
                  if (d2 <= 1e-6) continue;
                  const R = REPULSION_RADIUS;
                  if (d2 < R * R) {
                    const d = Math.sqrt(d2);
                    const nx = dx / d;
                    const ny = dy / d;
                    const proximity = 1 - (d / R); // 0..1 чем ближе, тем больше
                    const cf = (centerFactor(aPos) + centerFactor(bPos)) * 0.5;
                    const mag = REPULSION_STRENGTH * proximity * proximity * cf; // квадратично по близости
                    const ax = nx * mag;
                    const ay = ny * mag;
                    // Симметрично применяем
                    A.vx += ax * dt;
                    A.vy += ay * dt;
                    B.vx -= ax * dt;
                    B.vy -= ay * dt;
                  }
                }
              }
            }

            // Затухание скоростей отталкивания и ограничение
            for (const o of objects) {
              o.vx *= DAMPING;
              o.vy *= DAMPING;
              if (o.vx > VX_CLAMP) o.vx = VX_CLAMP;
              else if (o.vx < -VX_CLAMP) o.vx = -VX_CLAMP;
              if (o.vy > VY_CLAMP) o.vy = VY_CLAMP;
              else if (o.vy < -VY_CLAMP) o.vy = -VY_CLAMP;
            }

            // Движение падающих объектов
            for (let i = objects.length - 1; i >= 0; i--) {
              const o = objects[i];
              const m = o.mesh;
              const t = (m.position.y - BOTTOM_Y) / (TOP_Y - BOTTOM_Y); // 1..0
              const steer = -m.position.x * FUNNEL_STRENGTH * (1 - Math.max(0, Math.min(1, t)));
              m.position.x += (o.vx + steer) * dt;
              m.position.y += o.vy * dt; // отталкивание может немного поднимать/опускать
              m.position.y -= fallSpeed * dt; // падение с динамической скоростью
              m.rotation.x += o.rot.x * dt;
              m.rotation.y += o.rot.y * dt;
              m.rotation.z += o.rot.z * dt;

              // Отскок от боковых стен
              const left = -halfW + o.radius;
              const right = halfW - o.radius;
              if (m.position.x < left) {
                m.position.x = left;
                o.vx = Math.abs(o.vx) * BOUNCE_X;
              } else if (m.position.x > right) {
                m.position.x = right;
                o.vx = -Math.abs(o.vx) * BOUNCE_X;
              }

              // Исчезновение внизу в центре
              if (m.position.y <= BOTTOM_Y) {
                const nearCenter = Math.abs(m.position.x) < VANISH_RADIUS_X;
                if (nearCenter) {
                  scene.remove(m);
                  objects.splice(i, 1);
                } else {
                  // усиленно тянем к центру, чтобы не застревали
                  m.position.x *= 0.96;
                }
              }
            }

            // Управление от руки: мягко тянем игрока к цели, если недавно видели руку
            const tracking = handSeenAt && (performance.now() - handSeenAt < 300);
            if (tracking) {
              const tx = handTarget.x;
              const ty = handTarget.y;
              const nx = THREE.MathUtils.lerp(player.position.x, tx, HAND_SMOOTH);
              const ny = THREE.MathUtils.lerp(player.position.y, ty, HAND_SMOOTH);
              setPlayerWorld(nx, ny);
            }

            // Индикатор отслеживания: обновляем, если состояние изменилось
            if (tracking !== handActive) {
              handActive = tracking;
              handIndicatorEl.classList.toggle('on', handActive);
              const label = handIndicatorEl.querySelector('.label');
              if (label) label.textContent = handActive ? 'Рука: есть' : 'Рука: нет';
            }

            // Проверка столкновений
            for (let i = 0; i < objects.length; i++) {
              const o = objects[i];
              const dx = o.mesh.position.x - player.position.x;
              const dy = o.mesh.position.y - player.position.y;
              const r = o.radius + playerRadius;
              if (dx * dx + dy * dy <= r * r) {
                if (o.isCoin) {
                  collectCoin(i);
                } else {
                  gameOver();
                }
                break;
              }
            }
          }

          // Частицы взрыва
          for (let i = particles.length - 1; i >= 0; i--) {
            const p = particles[i];
            p.life -= dt;
            p.mesh.position.addScaledVector(p.vel, dt);
            p.mesh.rotation.x += 2.0 * dt;
            p.mesh.rotation.y -= 1.7 * dt;
            const fade = Math.max(0, p.life);
            p.mesh.material.opacity = fade;
            p.mesh.material.transparent = true;
            if (p.life <= 0) {
              scene.remove(p.mesh);
              particles.splice(i, 1);
            }
          }

          renderer.render(scene, camera);
          requestAnimationFrame(animate);
        }

        // Начальная позиция игрока к центру контейнера
        setTimeout(() => {
          const rect = container.getBoundingClientRect();
          handlePointer(rect.left + rect.width / 2, rect.top + rect.height * 0.5);
        }, 0);

        // Инициализация жестов руки
        setupHands();

        animate();
      })();
    </script>
  </body>
  </html>
